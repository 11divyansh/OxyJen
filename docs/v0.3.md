## Oxyjen v0.3 Documentation

**Version:** 0.3.0  
**Status:** In Development  
**Focus:** Structured Intelligence — Prompts, Schemas, Reliable Outputs  

---

## Overview

Oxyjen v0.3 introduces structured intelligence to Java AI pipelines.

Instead of unpredictable text, you can now enforce JSON schemas, validate model output, and automatically retry until the structure is correct.

At the core:

- Prompt templates for reusable prompts
- JSON schemas for structured outputs
- Automatic validation + retry
- SchemaNode for graph integration

---

## What v0.3 Solves

### Before v0.3

```java
String response = model.chat("Extract person info: John Smith, age 30");
// Could be anything:
// "John Smith is 30"
// "{ name: John }"
// invalid JSON
// random formats
```
### With v0.3
```java
JSONSchema schema = JSONSchema.object()
    .property("name", PropertySchema.string("Person name"))
    .property("age", PropertySchema.number("Person age"))
    .required("name", "age")
    .build();

SchemaEnforcer enforcer = new SchemaEnforcer(model, schema);

String json = enforcer.execute(
    "Extract person info: John Smith, age 30"
);

// Always valid JSON:
// {"name":"John Smith","age":30}
```
---

Core Concepts

**Prompt Templates**
- Prompt templates let you define prompts with variables and fill them at runtime.

**Basic Usage**
```java
PromptTemplate template = PromptTemplate.of(
    "Hello {{name}}, you are {{age}} years old."
);

String result = template.render(
    "name", "Alice",
    "age", 25
);
```
**Required / Optional Variables**
```java
PromptTemplate template = PromptTemplate.of(
    "Hello {{name}}, role: {{role}}",
    Variable.required("name"),
    Variable.optional("role", "guest")
);

// Uses default role
template.render("name", "Alice");

// Override default
template.render("name", "Bob", "role", "admin");
```
Variables are provided at execution time, not on nodes.

**JSON Schema**
JSONSchema defines the structure your LLM output must follow.

***Creating a Schema***
```java
JSONSchema schema = JSONSchema.object()
    .description("Person information")
    .property("name", PropertySchema.string("Full name"))
    .property("age", PropertySchema.number("Age"))
    .property("active", PropertySchema.bool("Is active"))
    .property("status", PropertySchema.enumOf(
        "Account status",
        "active", "inactive", "pending"
    ))
    .required("name", "age")
    .build();
```
**Supported types in v0.3:**
- string
- number
- boolean
- enum (string with fixed values)

**Schema Validation**
Validate any JSON string against a schema.
```java
SchemaValidator validator = new SchemaValidator(schema);

ValidationResult result = validator.validate(json);

if (!result.isValid()) {
    System.out.println(result.formatErrors());
}
```
***ValidationResult exposes:***
- isValid()
- errors() → List<FieldError>
- formatErrors()

***Each FieldError includes:***
- fieldPath
- errorType
- expected
- received
- message

**Schema Enforcement**
SchemaEnforcer automatically retries the model until valid JSON is produced (or retries are exhausted).
```java
SchemaEnforcer enforcer =
    new SchemaEnforcer(model, schema, 3);

String json = enforcer.execute(
    "Extract person info from: Alice Smith is 30"
);
```
Internally:

LLM -> validate -> retry with errors -> repeat
If all retries fail, SchemaException is thrown.

**SchemaNode (Graph Integration)**
SchemaNode combines:

- ChatModel

- JSONSchema

- SchemaEnforcer

It acts as the boundary between text and structured data.

Signature (v0.3):

String → Map<String,Object>
Creating a SchemaNode:
```java
SchemaNode node = SchemaNode.builder()
    .model("gpt-4o-mini")
    .schema(schema)
    .memory("extractions")
    .build();
```
---

Public API (v0.3)
Prompts
- PromptTemplate.of(...)
- template.render(...)
- Variable.required(...)
- Variable.optional(...)

Schema
- JSONSchema.object()
- PropertySchema.string(...)
- PropertySchema.number(...)
- PropertySchema.bool(...)
- PropertySchema.enumOf(...)

Validation
- SchemaValidator.validate(...)
- ValidationResult
- FieldError
- Enforcement
- SchemaEnforcer.execute(...)
- SchemaException

Graph
- SchemaNode.builder()...
- SchemaNode.process(...)

---

**Migration from v0.2**

v0.3 is backward compatible.

You can still use:

model.chat(...)

---

**Mental Model**

PromptTemplate = reusable prompt

JSONSchema = output contract

SchemaEnforcer = retry loop

SchemaNode = graph boundary (text → data)

---

##Examples

**Example 1**

Customer Support Classifier
Goal: Classify support tickets with structured outputs

```java
import io.oxyjen.core.*;
import io.oxyjen.llm.*;
import io.oxyjen.llm.prompts.*;
import io.oxyjen.llm.schema.*;

public class SupportClassifier {

    public static void main(String[] args) {

        PromptTemplate prompt = PromptTemplate.of("""
            You are a customer support ticket classifier for {{company_name}}.

            Classify this support ticket:
            "{{ticket_message}}"

            Determine:
            - Priority (low, medium, high, critical)
            - Department (billing, technical, sales, general)
            - Customer sentiment (happy, neutral, frustrated, angry)
            - Brief summary

            Respond ONLY with valid JSON.
            """,
            Variable.required("company_name"),
            Variable.required("ticket_message")
        );

        JSONSchema schema = JSONSchema.object()
            .property("priority", PropertySchema.enumOf(
                "Ticket priority",
                "low", "medium", "high", "critical"
            ))
            .property("department", PropertySchema.enumOf(
                "Handling department",
                "billing", "technical", "sales", "general"
            ))
            .property("sentiment", PropertySchema.enumOf(
                "Customer emotion",
                "happy", "neutral", "frustrated", "angry"
            ))
            .property("summary", PropertySchema.string("Brief issue summary"))
            .required("priority", "department", "sentiment", "summary")
            .build();

        SchemaNode classifyNode = SchemaNode.builder()
            .model("gpt-4o-mini")
            .schema(schema)
            .memory("support-tickets")
            .build();

        Graph pipeline = GraphBuilder.named("support-classifier")
            .addNode(classifyNode)
            .build();

        NodeContext ctx = new NodeContext();
        Executor executor = new Executor();

        String ticket =
            "I was charged twice for my subscription! I want a refund NOW!";

        // Render prompt 
        String renderedPrompt =
            prompt.render(
                "company_name", "Acme Corp",
                "ticket_message", ticket
            );

        // Then send rendered prompt to SchemaNode
        Map<String,Object> result =
            executor.run(pipeline, renderedPrompt, ctx);

        System.out.println(result);
    }
}
```

**Example 2**

Data Extraction Pipeline
Goal: Extract structured data from unstructured text.

```java
import io.oxyjen.core.*;
import io.oxyjen.llm.*;
import io.oxyjen.llm.schema.*;

public class DataExtractor {
    
    public static void main(String[] args) {
        // Define schema for person data
        JSONSchema personSchema = JSONSchema.object()
            .property("name", PropertySchema.string("Full name"))
            .property("age", PropertySchema.number("Age in years"))
            .property("email", PropertySchema.string("Email address"))
            .property("phone", PropertySchema.string("Phone number"))
            .property("city", PropertySchema.string("City of residence"))
            .required("name")  // Only name is required
            .build();
        
        // Create model with fallback
        ChatModel model = LLMChain.builder()
            .primary("gpt-4o")
            .fallback("gpt-4o-mini")
            .retry(3)
            .timeout(Duration.ofSeconds(10))
            .build();
        
        // Create enforcer
        SchemaEnforcer enforcer = new SchemaEnforcer(model, personSchema);
        
        // Extract from different formats
        String[] inputs = {
            "John Smith is 35 years old, lives in NYC, email: john@example.com",
            "Name: Alice Johnson, Age: 28, San Francisco, (415) 555-0123",
            "Bob Williams, age 42, bob.w@company.com"
        };
        
        for (String input : inputs) {
            String json = enforcer.execute(
                "Extract person information from: " + input
            );
            System.out.println(json);
        }
        
        /*
        Output:
        {"name": "John Smith", "age": 35, "email": "john@example.com", "city": "NYC"}
        {"name": "Alice Johnson", "age": 28, "city": "San Francisco", "phone": "(415) 555-0123"}
        {"name": "Bob Williams", "age": 42, "email": "bob.w@company.com"}
        */
    }
}
```
